#!/usr/bin/env ruby
begin
  require 'optparse'
  require 'series'
  require 'series/command'
  require 'shellwords'

  options = Series::Command.options()
  OptionParser.new do |opts|
    opts.banner = %{
usage: series [options] COMMANDS...

  Generate series data from the specified subcommands.

options:
}.lstrip

    opts.on("-h", "--help", "print this help") do
      puts opts
      puts
      puts Series.version
      exit
    end

    opts.on("-n", "--n-steps NUM", "number of steps in series (#{options[:n_steps]})") do |value|
      options[:n_steps] = value.to_i
    end

    opts.on("-o", "--offset NUM", "step offset (#{options[:offset]})") do |value|
      options[:offset] = value.to_i
    end

    opts.on("-s", "--step-size NUM", "the step size (#{options[:step_size]})") do |value|
      options[:step_size] = value.to_i
    end
  end.parse!

  commands = ARGV.dup; ARGV.clear

  pipes = commands.map do |command_str|
    command, *args = Shellwords.shellsplit(command_str)
    args.unshift("series-#{command}")
    IO.popen(args, "r+")
  end

  Thread.new do
    driver = Series::Command.driver(options)
    driver.each do |input|
      pipes.each do |io|
        io.puts input
      end
    end
    pipes.each do |io|
      io.close_write
    end
  end

  loop do
    line = []
    pipes.map do |io|
      if output = io.gets
        line << output.chomp("\n")
      else
        exit
      end
    end
    puts line.join(" ")
  end

rescue Interrupt
  exit 130
rescue Errno::EPIPE
  exit 0
end
