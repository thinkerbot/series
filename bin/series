#!/usr/bin/env ruby
this_file = File.symlink?(__FILE__) ? File.expand_path(File.readlink(__FILE__), File.dirname(__FILE__)) : __FILE__
$:.unshift File.expand_path('../../lib', this_file)

begin
require 'optparse'
require 'series'

if ARGV.empty?
  ARGV << '-h'
end

driver = nil
format = "%2$s\n"
throttle = nil
round = false

OptionParser.new do |opts|
  opts.banner = %{
usage: #{File.basename($0)} [options] SERIES [ARGS...]

  Generates a series in the specified format.

options:
}.lstrip
  opts.on("-h", "--help", "print this help") do
    puts opts
    puts
    exit
  end

  opts.on("-l", "--list", "list available series") do
    list = Series.list
    list.keys.sort.each do |name|
      puts name
    end
    exit
  end

  opts.on("-n NUM_OR_RANGE", "number of values to print") do |input|
    driver = Series.driver(input)

    if driver.nil?
      raise "invalid value for -n: #{input.inspect}"
    end
  end

  opts.on("-r", "--round", "round values to integers") do
    round = true
  end

  opts.on("-t", "--throttle NUM", "max speed in n/sec") do |input|
    throttle = input.to_f
  end

  opts.on("-x", "print x values") do
    format = "%s %s\n"
  end
end.parse!

if ARGV.empty?
  raise "no series specified"
end
args = ARGV.dup
ARGV.clear

series = Series.init(*args)
driver ||= Series.driver

driver.each do |x|
  if x == series.n
    y = series.curr
    series.step
  else
    y = series[x]
  end

  if round
    y = y.round
  end

  print format % [x, y]

  if throttle
    sleep(1.0/throttle)
  end
end

rescue Interrupt
  exit 130
rescue Errno::EPIPE 
  exit 0
rescue
  raise if $DEBUG
  $stderr.puts $!.message
  exit 1
end

