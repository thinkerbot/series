#!/usr/bin/env ruby
this_file = File.symlink?(__FILE__) ? File.expand_path(File.readlink(__FILE__), File.dirname(__FILE__)) : __FILE__
$:.unshift File.expand_path('../../lib', this_file)

begin
require 'optparse'
require 'series'

if ARGV.empty?
  ARGV << '-h'
end

min = 0
max = -1
round = false
throttle = nil
print_x = false

OptionParser.new do |opts|
  opts.banner = %{
usage: #{File.basename($0)} [options] SERIES [ARGS...]

  Generates a series in the specified format.

options:
}.lstrip
  opts.on("-h", "--help", "print this help") do
    puts opts
    puts
    exit
  end

  opts.on("-l", "--list", "list available series") do
    list = Series.list
    list.keys.sort.each do |name|
      puts name
    end
    exit
  end

  opts.on("-m", "--min NUM", "start index") do |input|
    unless input =~ /^-?\d+$/
      raise "invalid -m (non-numeric): #{input.inspect}"
    end

    min = input.to_i

    if min < 0
      raise "invalid -m (cannot be negative): #{input}"
    end
  end

  opts.on("-n", "--max NUM", "stop index") do |input|
    unless input =~ /^-?\d+$/
      raise "invalid -n (non-numeric): #{input.inspect}"
    end

    max = input.to_i
  end

  opts.on("-r", "--round", "round values to integers") do
    round = true
  end

  opts.on("-t", "--throttle NUM", "max speed in n/sec") do |input|
    throttle = input.to_f
  end

  opts.on("-x", "print x values") do
    print_x = true
  end
end.parse!

if ARGV.empty?
  raise "no series specified"
end
args = ARGV.dup
ARGV.clear

if max >= 0 && min > max
  # nothing to do...
  exit
end

series = Series.init(*args)

x = min
x.times { series.step }

loop do
  y = series.curr

  if print_x
    print "#{x} "
  end

  if round
    y = y.round
  end

  puts y

  if throttle
    sleep(1.0/throttle)
  end

  if max < 0 || x < max
    series.step
    x += 1
  else
    break
  end
end

rescue Interrupt
  exit 130
rescue Errno::EPIPE 
  exit 0
rescue
  raise if $DEBUG
  $stderr.puts $!.message
  exit 1
end

