#!/usr/bin/env ruby
$:.unshift File.expand_path('../../lib', __FILE__)

begin
  require 'optparse'
  require 'series'
  require 'series/command'
  require 'shellwords'

  options = Series::Command.options(
    :field_sep => " ",
    :line_sep  => "\n",
    :print_step_indexes => false,
    :precision => false,
    :unbuffer => false,
    :headers => false,
  )
  OptionParser.new do |opts|
    opts.banner = %{
usage: series [options] COMMANDS...

  Generate series data from the specified subcommands.

options:
}.lstrip

    opts.on("-F", "--field-sep SEP", "field separator (#{options[:field_sep].inspect})") do |value|
      options[:field_sep] = value
    end

    opts.on("-L", "--line-sep SEP", "line separator (#{options[:line_sep].inspect})") do |value|
      options[:line_sep] = value
    end

    opts.on("-H", "--header-line", "prints header line") do
      options[:headers] = true
    end

    opts.on("-h", "--help", "print this help") do
      puts opts
      puts
      puts Series.version
      exit
    end

    opts.on("-i", "--[no-]step-index", "print step index") do |value|
      options[:print_step_indexes] = value
    end

    opts.on("-m", "--stream", "generate steps indefinitely") do
      options[:n_steps] = nil
    end

    opts.on("-n", "--n-steps NUM", "number of steps in series (#{options[:n_steps]})") do |value|
      options[:n_steps] = value.to_i
    end

    opts.on("-o", "--offset NUM", "step offset (#{options[:offset]})") do |value|
      options[:offset] = value.to_i
    end

    opts.on("-r", "--round NUM", "round to precision") do |value|
      options[:precision] = value.to_i
    end

    opts.on("-s", "--step-size NUM", "the step size (#{options[:step_size]})") do |value|
      options[:step_size] = value.to_i
    end

    opts.on("-u", "--[no-]unbuffer", "unbuffer output") do |value|
      options[:unbuffer] = value
    end
  end.parse!

  commands = ARGV.dup; ARGV.clear
  readers, writers, headers = [], [], []

  if options[:unbuffer]
    $stdout.sync = true
  end

  if print_step_indexes = options[:print_step_indexes]
    r, w = IO.pipe
    readers << r
    writers << w
    headers << "N"
  end

  commands.each_with_index do |command_str, index|
    header_command, *args = Shellwords.shellsplit(command_str)
    header, command = header_command.split(":", 2)
    command, header = header, "#{header}_#{index}" if command.nil?
    args.unshift("series-#{command}")
    io = IO.popen(args, "r+")
    readers << io
    writers << io
    headers << header
  end

  Thread.new do
    driver = Series::Command.driver(options)
    driver.each do |input|
      writers.each do |io|
        io.puts input
      end
    end
    writers.each do |io|
      io.close_write
    end
  end

  field_sep = options[:field_sep]
  line_sep = options[:line_sep]
  precision = options[:precision]

  if options[:headers]
    print headers.join(field_sep)
    print line_sep
  end

  loop do
    fields = []
    readers.each do |io|
      if output = io.gets
        if precision
          fields << Float(output).round(precision)
        else
          fields << output.chomp("\n")
        end
      else
        exit
      end
    end
    print fields.join(field_sep)
    print line_sep
  end

rescue Interrupt
  exit 130
rescue Errno::EPIPE
  exit 0
end
